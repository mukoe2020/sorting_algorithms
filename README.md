## Sorting Algorithms And Big O Notation - Project

![Alt text](https://embed-ssl.wistia.com/deliveries/70d6f4e10e2badb5ef394f00c17ad2bc1c14f6e7.jpg)

Sorting algorithms are algorithms that rearrange elements in a list or array in a specific order, typically in ascending or descending order based on some comparison criteria. Sorting is a fundamental operation in computer science and is used in various applications, such as searching, data analysis, and information retrieval. There are many different sorting algorithms, each with its own characteristics and performance trade-offs. In this project, we implemented a series of some of the sorting algorithms.

## Project's Programming Language
* C 

## Styles
* Betty linter

## Authors

- [@habibaadam](https://www.github.com/habibaadam)
- [@mukoe2020](https://www.github.com/mukoe2020)

## Compilation

```bash
gcc -Wall -Wextra -Werror -pedantic  -std=gnu89 *.c -o <nameofobjectfile>
```

## Big O notation/ Time Complexity
Big O notation, often referred to as time complexity, is a mathematical notation used to describe the upper bound or worst-case behavior of an algorithm's runtime as a function of its input size. It provides a way to analyze and compare the efficiency of algorithms without getting into fine-grained details, In summary
Big O notation is a tool for expressing and comparing the efficiency of algorithms by providing an upper bound on their runtime in relation to the input size, helping us make informed choices when selecting algorithms for various tasks. With every sorting algorithm, there are best cases, average cases and worst cases when it comes to the time they take to run. The following table shows the algorithms done in this project, and their time complexities

Sorting Algorithm   | Description
------------------- |-----------------------------
Bubble Sort         | * Simple sorting algorithm that repeatedly steps through the list, compares adjacent
                    | elements and sorts them if they are in wrong order.
                    | * Relatively inefficient for large datasets but easy to understand and implement.
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |
                    |